---
layout:     post
title:      分布式系统下一致性hash的作用及实现原理
subtitle:   一致性hash算法在分布式系统中的运用
date:       2018-03-10
author:     vito
header-img: img/post-bg-os-metro.jpg
catalog: true
tags:
    - 分布式
---
## 场景描述
假设我们有三台缓存服务器，编号为0号，1号，2号。现在，我们需要缓存三万张图，而且希望图片被均匀缓存到这三台服务器上，以便分担缓存压力。应该怎样去做呢？     
- #### hash(图片名称)%N（节点数量） ####  
  首先我们想到的肯定是常规的hash算法：因为图片名称肯定是不会重复的，我们有三台服务器，即可hash后对3取模，余数一定是0、1、或者2，正好对应3台服务器的编号。所以当我们任意访问一张图片的时候，只需要对其名称进行上述运算，即可快速知道它处在哪一台服务器，进而在该台服务器上查找即可。  

> **问题** ： 如果有一天，我们发现三台缓存服务器已经不足已满足我们的缓存要求了，这个时候还能够使用原来的hash算法进行图片的缓存吗？  

如果我们此时，我们添加了两台服务器，假设我们任然沿用传统的hash进行处理，会出现什么后果呢？  
显而易见，因为机器节点数量发生了变化，所有的缓存图片位置都将发生改变。即：在节点数量发生改变后的一段时间内，缓存的作用几乎为0，再甚，可能由于此时大量缓存的失效，造成了缓存的雪崩，前端缓存无法起到太大的作用，导致后端服务器被压垮！   
所以，这种方式是分布式下绝对不可取的。此时，一致性hash算法应运而生了。  
### 一致性Hash算法 ###  
具体原理：  
**先构造一个长度为2^32的整数环（这个环被称为一致性Hash环），根据节点名称的Hash值（其分布为[0, 2^32-1]）将服务器节点放置在这个Hash环上，然后根据数据的Key值计算得到其Hash值（其分布也为[0, 2^32-1]），接着在Hash环上顺时针查找距离这个Key值的Hash值最近的服务器节点，完成Key到服务器的映射查找。**  

 如下图：
![hash](/img/hash-3.png)
* 大家可以想象一下，当新的服务器插入的时候，需要迁移的数据，仅仅是它所处的节点到离他顺时针最近的那块节点的区域。**这大大减少了数据迁移所带来的cache miss 问题**
* 此时，我们已经解决了最为重要的一个问题---cache miss，再想想看，我们希望缓存的图片均匀分布在每台服务器上，那么如果一致性hash能满足吗？  
---
答：很明显，不满足，因为数据本身的hash值并未发生变化，**节点在环上分布不均匀，导致了每个节点实际占据环上的区间大小不一**
，这种情况下，会出现某一节点可能有着巨大的负载。  
![hash-1](/img/hash-5.png)

### 改进-虚节点 ###
既然我们知道了节点所占的环控件决定了机器的负载，那么我们可以通过增加虚节点的方法，使得每个节点在环上所“管辖”更加均匀。这样就既保证了在节点变化时，尽可能小的影响数据分布的变化，而同时又保证了数据分布的均匀。也就是靠增加“节点数量”加强管辖区间的均匀。  
如下图:
![hash-model](/img/hash-model.png)
这才是真正意义上的一致性Hash！  
这样，我们就完成了在分布式系统下缓存服务器的高可用了！  
接下来，我们来考虑一下，在代码层面，应该如何去实现简单的一致性Hash呢？
有以下几个问题需要我们考虑一下：  
1、一个真实结点如何对应成为多个虚拟节点？  

2、虚拟节点找到后如何还原为真实结点？  

这两个问题其实有很多解决办法，我这里使用了一种简单的办法，给每个真实结点后面根据虚拟节点加上后缀再取Hash值，比如"192.168.0.0:111"就把它变成"192.168.0.0:111&&VN0"到"192.168.0.0:111&&VN4"，VN就是Virtual Node的缩写，还原的时候只需要从头截取字符串到"&&"的位置就可以了。

通过采取虚拟节点的方法，一个真实结点不再固定在Hash换上的某个点，而是大量地分布在整个Hash环上，这样即使上线、下线服务器，也不会造成整体的负载不均衡。

---

如此一来，就可以动手敲代码了，附上代码：
```
 /**
 * 一致性Hash算法
 * @author vitoLiu
 */
public class ConsistentHashingWithVirtualNode
{
    /**
     * 待添加入Hash环的服务器列表
     */
    private static String[] servers = {"192.168.0.0:111", "192.168.0.1:111", "192.168.0.2:111",
            "192.168.0.3:111", "192.168.0.4:111"};

    /**
     * 真实结点列表,考虑到服务器上线、下线的场景，即添加、删除的场景会比较频繁，这里使用LinkedList会更好
     */
    private static List<String> realNodes = new LinkedList<String>();

    /**
     * 虚拟节点，key表示虚拟节点的hash值，value表示虚拟节点的名称
     */
    private static SortedMap<Integer, String> virtualNodes =
            new TreeMap<Integer, String>();

    /**
     * 虚拟节点的数目，这里写死，为了演示需要，一个真实结点对应5个虚拟节点
     */
    private static final int VIRTUAL_NODES = 5;

    static
    {
        // 先把原始的服务器添加到真实结点列表中
        for (int i = 0; i < servers.length; i++)
            realNodes.add(servers[i]);

        // 再添加虚拟节点，遍历LinkedList使用foreach循环效率会比较高
        for (String str : realNodes)
        {
            for (int i = 0; i < VIRTUAL_NODES; i++)
            {
                String virtualNodeName = str + "&&VN" + String.valueOf(i);
                int hash = getHash(virtualNodeName);
                System.out.println("虚拟节点[" + virtualNodeName + "]被添加, hash值为" + hash);
                virtualNodes.put(hash, virtualNodeName);
            }
        }
        System.out.println();
    }

    /**
     * 使用FNV1_32_HASH算法计算服务器的Hash值,这里也可以自己重写hashCode的方法，最终效果没区别
     */
    private static int getHash(String str)
    {
        final int p = 16777619;
        int hash = (int)2166136261L;
        for (int i = 0; i < str.length(); i++)
            hash = (hash ^ str.charAt(i)) * p;
        hash += hash << 13;
        hash ^= hash >> 7;
        hash += hash << 3;
        hash ^= hash >> 17;
        hash += hash << 5;

        // 如果算出来的值为负数则取其绝对值
        if (hash < 0)
            hash = Math.abs(hash);
        return hash;
    }

    /**
     * 得到应当路由到的结点
     */
    private static String getServer(String node)
    {
        // 得到带路由的结点的Hash值
        int hash = getHash(node);
        // 得到大于该Hash值的所有Map
        SortedMap<Integer, String> subMap =
                virtualNodes.tailMap(hash);
        // 第一个Key就是顺时针过去离node最近的那个结点
        Integer i = subMap.firstKey();
        // 返回对应的虚拟节点名称，这里字符串稍微截取一下
        String virtualNode = subMap.get(i);
        return virtualNode.substring(0, virtualNode.indexOf("&&"));
    }

    public static void main(String[] args)
    {
        String[] nodes = {"127.0.0.1:1111", "221.226.0.1:2222", "10.211.0.1:3333"};
        for (int i = 0; i < nodes.length; i++)
            System.out.println("[" + nodes[i] + "]的hash值为" +
                    getHash(nodes[i]) + ", 被路由到结点[" + getServer(nodes[i]) + "]");
    }
}
```
看一下运行的结果：
```
虚拟节点[192.168.0.0:111&&VN0]被添加, hash值为1686427075
虚拟节点[192.168.0.0:111&&VN1]被添加, hash值为354859081
虚拟节点[192.168.0.0:111&&VN2]被添加, hash值为1306497370
虚拟节点[192.168.0.0:111&&VN3]被添加, hash值为817889914
虚拟节点[192.168.0.0:111&&VN4]被添加, hash值为396663629
虚拟节点[192.168.0.1:111&&VN0]被添加, hash值为1032739288
虚拟节点[192.168.0.1:111&&VN1]被添加, hash值为707592309
虚拟节点[192.168.0.1:111&&VN2]被添加, hash值为302114528
虚拟节点[192.168.0.1:111&&VN3]被添加, hash值为36526861
虚拟节点[192.168.0.1:111&&VN4]被添加, hash值为848442551
虚拟节点[192.168.0.2:111&&VN0]被添加, hash值为1452694222
虚拟节点[192.168.0.2:111&&VN1]被添加, hash值为2023612840
虚拟节点[192.168.0.2:111&&VN2]被添加, hash值为697907480
虚拟节点[192.168.0.2:111&&VN3]被添加, hash值为790847074
虚拟节点[192.168.0.2:111&&VN4]被添加, hash值为2010506136
虚拟节点[192.168.0.3:111&&VN0]被添加, hash值为891084251
虚拟节点[192.168.0.3:111&&VN1]被添加, hash值为1725031739
虚拟节点[192.168.0.3:111&&VN2]被添加, hash值为1127720370
虚拟节点[192.168.0.3:111&&VN3]被添加, hash值为676720500
虚拟节点[192.168.0.3:111&&VN4]被添加, hash值为2050578780
虚拟节点[192.168.0.4:111&&VN0]被添加, hash值为586921010
虚拟节点[192.168.0.4:111&&VN1]被添加, hash值为184078390
虚拟节点[192.168.0.4:111&&VN2]被添加, hash值为1331645117
虚拟节点[192.168.0.4:111&&VN3]被添加, hash值为918790803
虚拟节点[192.168.0.4:111&&VN4]被添加, hash值为1232193678

[127.0.0.1:1111]的hash值为380278925, 被路由到结点[192.168.0.0:111]
[221.226.0.1:2222]的hash值为1493545632, 被路由到结点[192.168.0.0:111]
[10.211.0.1:3333]的hash值为1393836017, 被路由到结点[192.168.0.2:111]
```
大功告成！

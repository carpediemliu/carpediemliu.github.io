---
layout:     post
title:      Java并发编程笔记
subtitle:   
date:       2017-12-10
author:     vito
header-img: img/home-bg-art.jpg
catalog: true
tags:
    - Java
    - concurrency
    - JMM
---
##	volatile与synchronized关键字
***
1	合理使用并发
1.1	单线程程序并不一定比多线程程序性能差

1）	当任务较轻，执行任务的消耗没有开启多线程消耗多时；

2）	当上下文切换带来的消耗较高时；

3）	当多线程的同步处理代价过大时；
***
1.2	并发的优势

1）	提高系统的吞吐率：能够合理的利用IO等待时间等情况；

2）	提高响应性：防止因为处理业务等待导致响应时间过长；

3）	充分利用多核CPU资源：单线程程序对多核CPU使用效率不高；

4）	最小化系统资源的使用：线程共享资源，避免了多进程造成的资源浪费；

5）	简化程序结构：现实世界是并行的，多线程能够更容易的表达现实世界；

1.3	如何减少上下文切换？

1）	无锁并发编程：不同的线程尽可能减少共享数据的范围，或者不共享数据；对于共享数据，可以考虑将数据分片，操作时，不同的线程访问不同的分片，从而减小数据共享范围；

2）	CAS算法：使用CAS算法，通过乐观锁代替悲观锁，减少不必要的锁；

3）	最少线程：线程并非越多越好，使用合适的线程数，避免产生大量的上下文切换；

4）	协程：在单个线程中实现多任务调度，并在单个线程里维护多个任务间的切换；

1.4	如何避免死锁？

1）	避免一个线程同时获取多个锁；

2）	避免一个线程在锁内同时占用多个资源，尽量保证一个锁只占用一个资源；

3）	使用定时锁tryLock代替内部锁机制，通过锁超时打破死锁；

4）	对于数据库锁，加锁和解决应该放在一个会话（连接）中；

2	volatile关键字

2.1	核心功能

1）	保证内存可见性：一个线程对一个被volatile修饰的变量值的更改，对于后面要访问该变量的线程总是可见的；

2）	禁止指令重排序：禁止编译器和CPU进行指令重排序；

2.2	cpu术语

Cpu术语	描述

内存屏障	一组处理器指令，用于实现对内存操作的限制；

缓存行	CPU高速缓存中可以分配的最小存储单位，处理器填写缓存行时，会加载整个缓存行；

原子操作	不可中断的一个或者一系列操作；

缓冲行填充	当处理器识别到从内存中读取操作数是可缓存的，则处理器会读取整个高速缓存行到适当的缓存；（L1,L2,L3的或所有）

缓存命中	如果进行高速缓存行填充操作的内存位置仍然是下一次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存读取；

写命中	当处理器将操作数写到一个内存的区域时，会首先检查缓存的内存地址是否在缓存行中，如果存在且有效，则处理器将操作数回写到高速缓存；

写缺失	一个有效的缓存行被写入到不存在的内存区域；

2.3	lock指令

1）	当volatile修饰的共享变量进行写操作时，会多出一条lock指令；

2）	lock指令的功能如下：

a)	将当前处理器缓存行中的数据写回到系统内存；

b)	写回内存操作会使其它CPU里缓存了该内存地址的数据无效；

3）	lock指令会被翻译称为LOCK#信号；LOCK#信号的功能用于保证处理器声言该信号时，保证cpu操作的数据对其它cpu可见；通常有如下两种实现：

a)	锁定总线：保持在处理器声言该信号时，能够独占内存；锁住总线，导致其它处理器不能访问总线，即其它处理器此时不可以访问内存；但锁定总线开销较大；

b)	锁定缓存：锁定当前处理器处理数据对应的高速缓存行，并回写数据到内存；通过处理器的缓存一致性协议来通知其它cpu数据发生变更；该实现相比而言开销较小；且由于缓存一致性协议的限制，不会出现同一时间多个cpu都更新同一数据的情况；

2.4	缓存一致性协议

1）	cpu实现了缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作时，会重新从系统内存中把数据读到处理器缓存里；

2）	缓存一致性协议会阻止同时修改两个以上的处理器缓存的内存数据区域；

2.5	编程技巧：通过追加字节，提高性能

1）	LinkedTransferQueue中，链表中的节点，通过定义无用的引用，将节点占用内存追加到64字节，从而保证处理器每次读取缓存行时，都只能读取一个节点的数据，避免了多个处理器同时访问相同缓存行的情况；

2）	如果不追加字节，则处理器每次固定读取64个字节的数据，有可能将队列的头结点和尾节点放入同一个缓存行，导致其它处理器无法同时访问同一缓存行，降低性能；

3）	适用场景：

a)	cpu字节宽度为64字节；

b)	共享变量被频繁写；

3	Synchronized关键字

3.1	核心功能

1）	实现操作的原子性：通过关键字设定临界区，保证同一时间仅有一个线程可以进入临界区；

2）	保证内存的可见性：一个线程执行临界区的代码对数据的修改，对后面进入临界区的线程可见；

3.2	实现基础

1）	Java中的每一个对象都可以作为锁；表现如下：

a)	普通同步方法（对象方法）：当前对象；

b)	静态同步方法（类方法）：当前类的类对象；

c)	同步方法块：括号中匹配的对象；

2）	JVM通过进入和退出Monitor对象来实现方法同步和代码块同步；两者实现细节不同；

3）	同步代码块：通过monitorenter和monitorexit指令实现；monitorenter指令是在编译后插入到同步代码块开始位置；monitorexit插入到方法结束处和异常处；JVM保证每个monitorenter指令都有与之对应的monitorexit指令；任何对象都有一个monitor对象与之关联，当monitor被持有后，即处于锁定状态；执行monitorenter指令时，会尝试获取对象对应的monitor的所有权，即尝试获取对象的锁；

4）	synchronized方法：则会被翻译成普通的方法调用和返回指令如:invokevirtual、areturn指令，在VM字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，而是在Class文件的方法表中将该方法的access_flags字段中的synchronized标志置为1，表示该方法是同步方法并使用调用该方法的对象或该方法所属的Class在JVM的内部对象表示Klass做为锁对象。

3.3	Java对象头

1）	Synchronized的锁存放在Java对象头中；如果对象是数组类型，则对象头占3个字，否则占两个字；例如：32位JVM中，一个字为4个字节，则数组类型的对象头占用12个字节，非数组类型的对象头占用8个字节；

3.3.1	对象头存储结构

存放内容	长度	描述

Mark Word	32/64bit	存放对象的hashcode、锁、分代年龄等信息；

Class Metadata Address	32/64bit	存放对象对应类型数据的指针；

ArrayLength	32/32bit	存放数组长度；（若当前对象为数组类型）

3.3.2	Mark Word存储结构

Mark Work中的数据会随着对象锁标志位的变化而变化；

3.3.2.1	32位JVM

锁状态	25bit	4bit	1bit

是否是偏向锁	2bit

锁标志位

	23bit	2bit			

无锁	对象hashcode	对象分代年龄	0	01

轻量级锁	指向栈中锁记录（Monitor Record）的指针	00

重量级锁	指向互斥量（重量级锁）的指针	10

GC标记	空	11

偏向锁	线程ID	对象分代年龄	1	01


问题1：当有锁状态时，原先的hashcode和分代年龄存放何处？是否是在解锁之后重新计算？

加锁时，线程将对象Mark Word存放到线程栈桢中的存储空间，称为：Displaced Mark Word；

解锁时，通过持有锁线程栈桢中存放的Mark Word替换回来；


问题2：轻量级锁和重量级锁存放指针的长度仅有30位，指针通常不是有32位，如何存放？


3.3.2.2	64位JVM

锁状态	25bit	31bit	1bit

cms_free	4bit

分代年龄	1bit

偏向锁	2bit

锁标志位

无锁	未使用	hashcode			0	01

偏向锁	线程ID(54bit)	Epoch（2bit）			1	01
